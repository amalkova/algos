# GOIT Algo HW-10 — Монети (Greedy vs DP) та інтеграл методом Монте-Карло

## Мета
1) Реалізувати видачу решти **жадібним алгоритмом** і **динамічним програмуванням** та порівняти ефективність.  
2) Обчислити визначений інтеграл **методом Монте-Карло** і звірити результат з **аналітичним** або **`scipy.integrate.quad`**.

---

## Структура
```
goit-algo-hw-10/
├── coins.py                 # Завдання 1: find_coins_greedy, find_min_coins
├── monte_carlo_integral.py  # Завдання 2: інтеграл методом Монте-Карло + порівняння з quad/аналітикою
├── main.py
└── README.md
```

**Вимоги**: Python 3.9+. Опційно: `numpy`, `matplotlib`, `scipy` (для quad та графіка).  
> Навіть без цих бібліотек код працює: Монте‑Карло через стандартний `random`, а для `x^2` є аналітика.

---

## Завдання 1 — видача решти (монети)

Монетний ряд за замовчуванням: **`[50, 25, 10, 5, 2, 1]`**.

### Функції
- `find_coins_greedy(amount, coins=None) -> dict`  
  Жадібний алгоритм: спочатку беремо найбільші номінали.  
  **Приклад**: `amount=113` → `{50: 2, 10: 1, 2: 1, 1: 1}`.
- `find_min_coins(amount, coins=None) -> dict`  
  Динамічне програмування (мінімальна кількість монет).  
  **Приклад**: `amount=113` → `{1: 1, 2: 1, 10: 1, 50: 2}` (у відсортованому вигляді це те саме рішення).

### Як запустити (приклад)
```bash
python3 -c "import coins; print('greedy:', coins.find_coins_greedy(113)); print('dp:', coins.find_min_coins(113))"
```

### Складність і ефективність
- **Greedy**: ~ **O(k)** (k — кількість номіналів). Для *канонічних* рядів монет (як у нас) greedy дає **оптимальний** розв’язок і працює дуже швидко навіть на великих сумах.
- **DP**: **O(k·S)** часу та **O(S)** пам’яті (S — сума). Дає оптимум **для будь‑якого** набору монет, але на великих сумах значно повільніший.

### Емпіричні вимірювання (1 прогін на цій машині)
| Сума | Greedy, ms | DP, ms |
|-----:|-----------:|-------:|
| 113      | ~0.009 | ~0.075 |
| 10 000   | ~0.004 | ~10.09 |
| 50 000   | ~0.005 | ~70.92 |
| 100 000  | ~0.008 | ~89.12 |

**Висновок (Завдання 1).** Для канонічного набору `[50,25,10,5,2,1]` обидва алгоритми дають однаковий оптимальний розклад, але **Greedy** суттєво швидший і масштабується краще. **DP** потрібен для неканонічних наборів монет, де greedy може не бути оптимальним.

---

## Завдання 2 — визначений інтеграл методом Монте‑Карло

Оцінка інтегралу:
\[
\int_a^b f(x)\,dx \approx (b-a)\cdot \frac{1}{n}\sum_{i=1}^{n} f(x_i),\quad x_i\sim U(a,b)
\]
Стандартна похибка масштабується як \(\propto 1/\sqrt{n}\).

### Як запустити (приклади)
```bash
# За замовчуванням у коді використовується f(x)=x^2, [0,2], n=100000
python3 -c "from monte_carlo_integral import monte_carlo_integral; f=lambda x:x*x; est,err=monte_carlo_integral(f,0.0,2.0,100000); print(est, err)"

# Збереження графіка (якщо є matplotlib/numpy)
python3 -c "from monte_carlo_integral import FUNCS, monte_carlo_integral, maybe_plot; f=FUNCS['x2']; est,err=monte_carlo_integral(f,0,2,100000); print(est,err); maybe_plot(f,0,2,'mc.png')"
```

### Перевірка точності
- **Аналітично** для \( f(x)=x^2 \) на \([0,2]\):
  \[
  \int_0^2 x^2 dx = \frac{2^3-0^3}{3} = \frac{8}{3} \approx 2.6666666667
  \]
- **Порівняння** (n = 100 000, f(x)=x², [0,2]):  
  Монте‑Карло ≈ **2.66103**, stderr ≈ **7.52e-03**;  
  `quad`/аналітика = **2.66667**;  
  різниця ≈ **−0.00564** ≈ **0.75·stderr** → у межах очікуваної статистичної похибки.

**Висновок (Завдання 2).** Метод Монте‑Карло дає несмещену оцінку інтеграла й сходиться до точного значення зі зростанням `n`. Різниця з аналітичним/`quad` результатом знаходиться в межах очікуваної похибки; збільшення `n` зменшує відхилення як \(1/\sqrt{n}\).

---

## Відповідність критеріям
- **Завдання 1:**  
  ✔ Жадібний алгоритм реалізовано, повертає словник номіналів/кількостей.  
  ✔ DP реалізовано, повертає словник з мінімальною кількістю монет.  
  ✔ Порівняння ефективності за часом і Big‑O наведено.  
  ✔ Висновки щодо ефективності додано.

- **Завдання 2:**  
  ✔ Метод Монте‑Карло реалізовано, повертає значення інтеграла.  
  ✔ Порівняння з аналітикою/`quad` виконано.  
  ✔ Висновки щодо правильності розрахунків додано.